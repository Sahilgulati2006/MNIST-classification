# -*- coding: utf-8 -*-
"""MNIST Digit classification

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UuKnyMnRNnGC3_Ryo6xhy6H-MTlpU_OQ

# **Step 1: Import Required Libraries**
# Import essential libraries for data processing, visualization, and building the neural network.
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sms
import cv2
from google.colab.patches import cv2_imshow
from PIL import Image
import tensorflow as tf
tf.random.set_seed(3)
from tensorflow import keras
from keras.datasets import mnist
from tensorflow.math import confusion_matrix

"""# **Step 2: Load and Preprocess the Data**
# Load MNIST dataset and preprocess it by normalizing and encoding the labels.

"""

(x_train, y_train ), (x_test , y_test) = mnist.load_data()

type(x_train)

print(x_train.shape, y_test.shape, x_train, y_train)

print(x_train[19])

plt.imshow(x_train[19])
plt.show

print(y_train[19])

print(np.unique(y_train))

print(x_train[1])

"""# Normalize the data to the range [0, 1]"""

x_train = x_train/255
x_test = x_test/255

"""# **Step 4: Define the Neural Network Model**
# Create a Sequential model with input, hidden, and output layers.

"""

model = keras.Sequential([
    keras.layers.Flatten(input_shape = (28,28)),
    keras.layers.Dense(150, activation = 'relu'),
    keras.layers.Dense(50, activation = 'relu'),
    keras.layers.Dense(10, activation = 'sigmoid')
])

"""# **Step 5: Compile the Model**
# Configure the model with optimizer, loss function, and evaluation metric.

"""

model.compile(optimizer = 'adam',
              loss = 'sparse_categorical_crossentropy',
              metrics = ['accuracy'])

"""# **Step 6: Train the Model**
# Fit the model on the training data and validate it on the test set.

"""

model.fit(x_train, y_train, epochs = 10)

"""# **Step 7: Evaluate the Model**
# Evaluate the model's performance on the test set and print the accuracy.

"""

loss, accuracy = model.evaluate(x_test,y_test)
print(loss)
print(accuracy)

print(x_test.shape)

y_predict = model.predict(x_test)

plt.imshow(x_test[0])
plt.show()

print(y_test[0])

print(y_predict.shape)

print(y_predict[0])

label_first_img = np.argmax(y_predict[0])
print(label_first_img)

y_pred_labels = [np.argmax(i) for i in y_predict]
print(y_pred_labels)

"""# **Step 8: Generate a Confusion Matrix**
# Create a confusion matrix to evaluate prediction performance.

"""

conf_matrix = confusion_matrix(y_test, y_pred_labels)
print(conf_matrix)

plt.figure(figsize = (16, 8))
sms.heatmap(conf_matrix, annot = True, fmt = 'd', cmap = 'Blues')
plt.ylabel('True labels')
plt.xlabel('Predicted labels')

"""# **Step 9: Build a Predictive System**
# Create a system to classify handwritten digits from input images.

"""

input_img_path = '/content/5.png'
input_img = cv2.imread(input_img_path)

type(input_img)

print(input_img)

cv2_imshow(input_img)

input_img.shape

grayscale = cv2.cvtColor(input_img, cv2.COLOR_BGR2GRAY)

grayscale.shape

gray_resized = cv2.resize(grayscale, (28,28))

gray_resized.shape

gray_resized = gray_resized/255

image_reshaped = np.reshape(gray_resized, (1,28,28))

input_prediction = model.predict(image_reshaped)
print(input_prediction)

input_prediction_label = [np.argmax(input_prediction)]
print(input_prediction_label)

input_path = input('Enter the path of the image to be predicted: ')
input_img = cv2.imread(input_path)

cv2_imshow(input_img)
grayscale = cv2.cvtColor(input_img, cv2.COLOR_BGR2GRAY)
resized_img = grayscale/255
reshaped_img = np.reshape(resized_img, (1,28,28))

prediction = model.predict(reshaped_img)
print('the handwritten digit is', prediction)